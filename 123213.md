# 频繁触发事件
  在用户交互的设计中，常常需要设定很多触发事件，而在很多场景中，我们设定的触发事件会由于动作的连续触发或者短时间内大量触发而随之不断调用，常用的主要有以下几种可能：
  1. 文字输入、自动完成的keyup事件
  2. 拖拽时的mousemove事件
  3. 射击游戏等需要大量点击的mousedown、keydown事件
  4. window对象的resize、scroll事件。 
  这些这将浪费大量的系统资源，而如果触发事件的回调函数过重，里面含有较多的dom操作、资源加载或者请求数据等内容，更有可能导致浏览器负担过重而挂起甚至崩溃，引起与预期不相符的的麻烦。
  那么如何避免这些麻烦呢，依据场景特点和需求的不同，主要有debounce和throttle两种方法，即去抖和节流。
  
## 去抖
### 应用场景举例
  如果我们现在场景有一个input输入框，这个输入框有模糊匹配和搜索的功能，使用者在输入的过程中，会根据其输入结果来自动联想匹配出一些结果供用户选择。一般来说，我们可能首先想到的做法就是监听keypress事件，然后异步去查询结果。这个方法本身思路和方向当然是正确的，但是如果用户快速的输入了一连串的字符，那么这个过程就会一直触发keypress的监听事件。如果用户输入了一个15个字符的关键词，那么就会在短时间内触发了15次的请求，而在过程中的查询，并不是用户所需要的，由于大量触发而浪费的资源也就是无意义的。我们想要的是用户停止输入的时候才去触发查询的请求，这时候就要用到去抖的方法，使得用户只在输入完成后才会去调用。
### 定义
   让某个函数在上一次执行后，满足等待某个时间内不再触发此函数后再执行，而在这个等待时间内再次触发此函数，等待时间会重新计算。类似于如果你用手压住一个弹簧，如果一直按着它将永远不会弹起，直到你按住的这个动作结束。核心思想是如果某个函数为连续触发或者高频触发，则指定其只在最后一次事件触发的一段时间后调用一次。
   具体的实现思路是：
   第一次触发事件去调用函数时，首先创建一个定时器，在指定的时间间隔之后运行方法的主体部分。当第二次触发再去调用该函数时，它会清除前一次的定时器并设置另一个。如果前一个定时器已经执行过了，那么这个操作其实就相当于没有改变什么。然而，如果前一个定时器尚未执行，那么这一步就是将其替换为一个新的定时器。目的是只有在执行函数的请求停止了一段时间之后才执行。  
 具体的代码示例如下：

```js
var debounce = function(delay, mainAction){
  var last = 0;
  return function(){
    var that = this;
    clearTimeout(last);
    last = setTimeout(function(){
        mainAction.apply(that, arguments)
    }, delay)
  }
}


```

## 节流
### 应用场景举例
  例如我们在滚动浏览器滚动条的时候，要随着关东更新页面上的某些dom元素，这其中就很可能需要去后台调用接口查询新的数据内容，如果我们对此触发事件没有进行限制，那么可能在一次滚动中会产生大量的调用，这不是我们想要的结果。这时候就要用节流的方法，在一定时间内只发生一次调用。当然，上面的输入查询的例子其实也可以做成节流，只是一般来说去抖更适合上面输入查询的场景要求和使用习惯。
### 定义
   在不断触发事件的过程中，只能隔一段固定的时间触发一次，而在这段时间之内，不能重复触发。类似于如果你认为某个水龙头的流量太大，你将这个水龙头拧到几乎最紧但留有一丝余地，这个水龙头会每隔一个固定的时间滴下一滴水。核心思想是如果某个函数为连续触发或者高频触发，则指定其只能在隔一段固定的时间才能去调用一次。
   它与去抖的本质区别是，在不断触发事件的过程中，调用函数其实是有发生的，它只是固定时间地稀释了，而不是像去抖那样，直到最后一次触发之前，调用函数都不曾执行过一次。
   具体的代码示例如下：
   
 ```js
var throttle = function(mainAction,interval){
  var last= new Date();
  return function(){
    var current = new Date();
    if (current - last > interval){
      mainAction.apply(this, arguments);
      last = current； 
    }
  }
}


```
## 总结与比较
   执行时机：去抖是在最后一次触发动作结束之后；节流是在触发动作过程之中。
   执行次数：去抖只有一次执行；节流在过程中多次执行，具体次数与设置间隔和持续执行时间有关。
   参数设置：去抖需设置最后一次动作停止后到调用函数的延迟时间；节流需设置触发过程中执行函数的间隔时间。
   使用目的：都是为了应对持续或大量触发事件对系统资源的浪费。
